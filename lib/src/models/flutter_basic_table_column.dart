/// A model representing the configuration and properties of a single table column.
///
/// Each column requires a unique `id`, a display `name`, and an `order` for its
/// initial position in the table. It also supports defining width constraints,
/// resizability, and custom tooltip behavior.
class BasicTableColumn {
  /// A unique identifier for the column. This ID is used internally for
  /// managing column properties, sorting, and reordering. It must be unique
  /// across all columns in a table.
  final String id;

  /// The display name of the column, shown in the table header.
  final String name;

  /// The initial display order of the column, starting from 0.
  /// Columns are sorted based on this `order` value.
  final int order;

  /// The minimum width that the column can shrink to.
  /// Defaults to 100.0.
  final double minWidth;

  /// The maximum width that the column can expand to.
  /// If `null`, there is no maximum width constraint.
  final double? maxWidth;

  /// A boolean indicating whether the column is resizable by the user.
  /// Defaults to `true`.
  final bool isResizable;

  /// An optional function that formats the tooltip message for cells in this column.
  ///
  /// If provided, this function will be called with the cell's display text,
  /// and its return value will be used as the tooltip message.
  /// If `null`, the original cell text will be used as the tooltip (if overflowed).
  final String Function(String value)? tooltipFormatter;

  /// A boolean indicating whether the tooltip should always be displayed for cells
  /// in this column, regardless of text overflow.
  ///
  /// If `true`, the tooltip will always show. If `false`, the tooltip will only
  /// appear if the cell's content overflows its boundaries.
  /// Defaults to `false`.
  final bool forceTooltip;

  /// Creates a [BasicTableColumn] with the specified properties.
  const BasicTableColumn({
    required this.id,
    required this.name,
    required this.order,
    this.minWidth = 100.0,
    this.maxWidth,
    this.isResizable = true,
    this.tooltipFormatter,
    this.forceTooltip = false,
  });

  /// Creates a simple [BasicTableColumn] where the `id` is derived from the `name`.
  ///
  /// The `id` is generated by converting the `name` to lowercase and replacing
  /// spaces with underscores (e.g., "User Name" becomes "user_name").
  factory BasicTableColumn.simple({
    required String name,
    required int order,
    double minWidth = 100.0,
    double? maxWidth,
    bool isResizable = true,
    String Function(String value)? tooltipFormatter,
    bool forceTooltip = false,
  }) {
    return BasicTableColumn(
      id: name.toLowerCase().replaceAll(' ', '_'),
      name: name,
      order: order,
      minWidth: minWidth,
      maxWidth: maxWidth,
      isResizable: isResizable,
      tooltipFormatter: tooltipFormatter,
      forceTooltip: forceTooltip,
    );
  }

  /// Creates a [BasicTableColumn] with a custom `id` that is different from its `name`.
  ///
  /// Use this constructor when the internal identifier needs to be distinct
  /// from the display name.
  factory BasicTableColumn.withCustomId({
    required String id,
    required String name,
    required int order,
    double minWidth = 100.0,
    double? maxWidth,
    bool isResizable = true,
    String Function(String value)? tooltipFormatter,
    bool forceTooltip = false,
  }) {
    return BasicTableColumn(
      id: id,
      name: name,
      order: order,
      minWidth: minWidth,
      maxWidth: maxWidth,
      isResizable: isResizable,
      tooltipFormatter: tooltipFormatter,
      forceTooltip: forceTooltip,
    );
  }

  /// Converts a [List] of [BasicTableColumn] objects into a [Map] where keys
  /// are the column IDs and values are the [BasicTableColumn] objects.
  ///
  /// Throws an [ArgumentError] if duplicate column IDs are found.
  static Map<String, BasicTableColumn> listToMap(
      List<BasicTableColumn> columns) {
    final Map<String, BasicTableColumn> result = {};

    for (final column in columns) {
      if (result.containsKey(column.id)) {
        throw ArgumentError('Duplicate column ID: ${column.id}');
      }
      result[column.id] = column;
    }

    return result;
  }

  /// Converts a [Map] of [BasicTableColumn] objects into a sorted [List]
  /// based on their `order` property.
  ///
  /// Columns with lower `order` values appear earlier in the list.
  static List<BasicTableColumn> mapToSortedList(
      Map<String, BasicTableColumn> columns) {
    final list = columns.values.toList();
    list.sort((a, b) => a.order.compareTo(b.order));
    return list;
  }

  /// Reorders a specific column within a map of columns and adjusts the `order`
  /// of other columns accordingly to maintain a continuous sequence.
  ///
  /// [columns]: The original map of columns.
  /// [columnId]: The ID of the column to reorder.
  /// [newOrder]: The new desired order (index) for the column.
  ///
  /// Returns a new map of columns with the updated order.
  /// Throws an [ArgumentError] if the `columnId` is not found.
  static Map<String, BasicTableColumn> reorderColumn(
    Map<String, BasicTableColumn> columns,
    String columnId,
    int newOrder,
  ) {
    if (!columns.containsKey(columnId)) {
      throw ArgumentError('Column not found: $columnId');
    }

    final targetColumn = columns[columnId]!;
    final oldOrder = targetColumn.order;

    if (oldOrder == newOrder) return columns;

    final result = Map<String, BasicTableColumn>.from(columns);

    // Adjust orders of other columns
    for (final entry in result.entries) {
      final column = entry.value;

      if (column.id == columnId) {
        // Target column gets the new order
        result[entry.key] = column.copyWith(order: newOrder);
      } else {
        // Other columns adjust their order as needed
        int adjustedOrder = column.order;

        if (oldOrder < newOrder) {
          // Moving backward: pull columns in between forward
          if (column.order > oldOrder && column.order <= newOrder) {
            adjustedOrder = column.order - 1;
          }
        } else {
          // Moving forward: push columns in between backward
          if (column.order >= newOrder && column.order < oldOrder) {
            adjustedOrder = column.order + 1;
          }
        }

        if (adjustedOrder != column.order) {
          result[entry.key] = column.copyWith(order: adjustedOrder);
        }
      }
    }

    return result;
  }

  /// Normalizes the `order` property of columns in a map to ensure they are
  /// sequential and start from 0.
  ///
  /// This is useful after reordering operations to maintain consistent order values.
  static Map<String, BasicTableColumn> normalizeOrders(
      Map<String, BasicTableColumn> columns) {
    final sortedList = mapToSortedList(columns);
    final result = <String, BasicTableColumn>{};

    for (int i = 0; i < sortedList.length; i++) {
      final column = sortedList[i];
      result[column.id] = column.copyWith(order: i);
    }

    return result;
  }

  /// Creates a copy of this [BasicTableColumn] with the given fields replaced
  /// with new values.
  BasicTableColumn copyWith({
    String? id,
    String? name,
    int? order,
    double? minWidth,
    double? maxWidth,
    bool? isResizable,
    String Function(String value)? tooltipFormatter,
    bool? forceTooltip,
  }) {
    return BasicTableColumn(
      id: id ?? this.id,
      name: name ?? this.name,
      order: order ?? this.order,
      minWidth: minWidth ?? this.minWidth,
      maxWidth: maxWidth ?? this.maxWidth,
      isResizable: isResizable ?? this.isResizable,
      tooltipFormatter: tooltipFormatter ?? this.tooltipFormatter,
      forceTooltip: forceTooltip ?? this.forceTooltip,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is BasicTableColumn &&
        other.id == id &&
        other.name == name &&
        other.order == order &&
        other.minWidth == minWidth &&
        other.maxWidth == maxWidth &&
        other.isResizable == isResizable &&
        other.forceTooltip == forceTooltip;
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      name,
      order,
      minWidth,
      maxWidth,
      isResizable,
      forceTooltip,
    );
  }

  @override
  String toString() {
    return 'BasicTableColumn(id: $id, name: $name, order: $order, minWidth: $minWidth)';
  }
}
